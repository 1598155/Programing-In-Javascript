<!DOCTYPE html>
<html>
<head>
<title>Javascript Generator - Javascript编程语言</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Javascript编程语言 - 一本开源的Javascript编程指南; An open-sourced Javascript Guide and Tutorial; Javascript Generator ES6中的Generator的引入，极大程度上改变了Javascript程序员对迭代器的看法，并为解决callback hell1提供了新方法。 Generator是一个与语言无关的特性，理论上它应该存在于所有Javascript引擎内，但是目前真正完整实现的，只有在node --harmony 下。所以后文所有的解释，都以node环境举例，需要的启动参数">
<meta name="keywords" content="Javascript, guide, open-sourced ,is,,0,,2,,3,,4,,5,,6,,8,,#,,Javascript,,Generator,,ES,,中的,,的,,引入,,，,,极大,,程度,,上,,改变,,了,,程序员,,对,,迭,,代,,器,,看法,,并,,为,,解决,,callback,,hell,,[,,^,,],,提供,,新方法,,。,,是,,一个,,与,,语言,,无关,,特性,,理论上,,它,,应该,,存,,在于,,所有,,引擎,,内,,但是,,目前,,真正,,完整,,实现,,只,,有,,在,,`,,node,,-,,harmony,,下,,所,,以后,,文所,,有的,,解释,,都,,以,,环境,,举例,,需要,,启动,,参数,,use,,_,,strict,,V,,中,,和,,标准,,之中,,说的,,又,,区别,,这个,,可以,,参考,,一下,,MDC,,相关,,文档,,而且,,写作,,这篇文章,,时,,并没有,,Iterator,,用作,,我们,,简单的,,例子,,开始,,：,,function,,*,,argumentsGenerator,,(,,),,{,,for,,let,,i,,=,,;,,&lt;,,arguments,,.,,length,,+,,yield,,},,希望,,传入,,每个,,实参,,var,,argumentsIterator,,&#x27;,,a,,,,,b,,c,,/,,Prints,,&quot;,,console,,log,,next,,value,,理解,,其实,,生成,,方法,,被称为,,GeneartorFunction,,也,,有些人,,把,,返回,,值,,称为,,Geneartor,,中断,,运行,,；,,而,,在下,,一次,,恢复,,成,,员,,能够,,其,,属性,,包含,,实际,,数值,,done,,布尔,,标记,,是否,,完成,,要,,注意的,,true,,后,,继续,,方法会,,产生,,异常,,完整的,,of,,循环,,正是,,为了,,快速,,iterator,,可惜,,版本,,不支持,,说到,,这里,,大多,,数,,经验,,会,,表示,,不屑,,因为,,这些,,通过,,自己,,编写,,函数,,来,,再来,,看,,fibonacci,,while,,序列,,无穷,,数字,,你,,用,,来生,,远,,没有用,,简洁,,个,,更,,有趣的,,利用,,语法,,将,,操作,,代理,,到,,另外,,delegatedIterator,,Hello,,!,,Bye,,delegatingIterator,,Greetings,,Ok,,bye,,流程,,控制,,暂停,,那么,,便,,执行,,可能,,这,,Python,,coroutine,,类似,,co,,https://github.com/visionmedia/co),,已经,,此,,封装,,非常,,完美了,,讨论,,&gt;,,The,,classic,,example,,this,,1,,consumer,,producer,,relationships,,:,,generators,,that,,produce,,values,,and,,then,,consumers,,them,,two,,are,,said,,to,,be,,symmetric,,–,,continuous,,evaluation,,where,,coroutines,,each,,other,,rather,,than,,functions,,call,,之所以,,可,,用来,,代码,,就是,,两个,,或者,,多,,路径,,互相,,切换,,这种,,语句,,级,,别的,,而不是,,调用,,本质,,CPS,,变幻,,文会,,给出,,补充,,若干,,行为,,接受,,表达式,,即,,既,,throw,,抛出,,终止,,GeneratorFunction,,return,,等同于,,异步,,“,,变,,”,,同步,,假设,,有如,,风格,,suspend,,回调,,看起来,,像,,给定,,特殊的,,让,,保证,,作为,,并且,,脚本,,过程,,错误,,都会,,全局,,具,,体,,如下,,fs,,require,,resume,,content,,readFile,,filename,,list,,readdir,,dirname,,e,,res,,上面,,分别,,进行,,读,,文件,,列,,目录,,均,,这样,,API,,slice,,Array,,prototype,,bind,,gen,,generator,,args,,ctx,,if,,up,,or,,send,,?,,ret,,&amp;,,run,,needed,,null,,apply,,unshift,,kickoff,,有容乃大,,支持,,形势,,显示,,那样,,更多,,作者,,对象,,归结为,,一种,,名为,,thunk,,形式,,那,,什么是,,呢,,？,,fn,,首先,,修改,,自动,,typeof,,shold,,注意,,这个时候,,能,,使用方法,,发生,,read,,wrap,,native,,passed,,接下来,,更加,,有用,,内容,,穿入,,Thunk,,isGeneratorFunction,,obj,,constructor,,name,,isGenerator,,check,,it,,s,,else,,assume,,使用,,三种,,one,,three,,当然,,大家,,明白,,如何,,兼容,,数据类型,,例如,,Promise,,、,,数组,,等,,但,,扩展,,就,,不再,,赘述,,说,,精简,,走上,,一条,,康庄大道,,不需要,,复杂的,,不用,,难看的,,async,,同时,,从,,性能,,角度,,后续,,优化,,进一步,,提升,,来说,,并不,,差,,转换,,糖,,底层,,方式,,便是,,变换,,也就是说,,递归,,重新,,根本,,用不着,,一,,定,,层面,,笔者,,认,,纯,,造成,,大量,,堆栈,,消耗,,毫无,,优势,,可言,,考虑,,编译,,更高,,关于,,细节,,之后,,文章,,Continuation,,Passing,,Style,,md,,详细,,解说,,http://callbackhell.com/,,https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators,,https://github.com/JustinDrake/node-es6-examples#generators,,http://dailyjs.com/2013/05/31/suspend/,,http://dailyjs.com/2013/10/17/yield/,,http://en.wikipedia.org/wiki/Continuation-passing_style">
<link rel="stylesheet" type="text/css" href="/style.css" />

</head>
<body>
<header class="clearfix">
  <div class="left back-toc">
    <ul class="inline-list">
      <li><a href="/">目录</a></li>
      
        <li class="seperator">></li>
        <li>Javascript核心</li>
      
        <li class="seperator">></li>
        <li>Functional_Javascript(Unlocalized)</li>
      
      
      <li class="seperator">></li>
      <li class="current"><strong>当前页面</strong></li>
      
    </ul>
  </div>
  <div class="right">
    <a href="/"><img src="/images/logo.png" alt="Javascript编程语言" width="256" height="50" /></a>
  </div>
</header>
<div class="primary">
  <h1 id="javascript-generator">Javascript Generator</h1>
<p>ES6中的Generator的引入，极大程度上改变了Javascript程序员对迭代器的看法，并为解决callback hell<sup id="fnref1"><a href="#fn1">1</a></sup>提供了新方法。</p>
<p>Generator是一个与语言无关的特性，理论上它应该存在于所有Javascript引擎内，但是目前真正完整实现的，只有在<code>node --harmony</code> 下。所以后文所有的解释，都以node环境举例，需要的启动参数为<code>node --harmony --use_strict</code>。</p>
<p>V8中所实现的Generator和标准之中说的又有区别，这个可以参考一下MDC的相关文档<sup id="fnref2"><a href="#fn2">2</a></sup>。而且，V8在写作这篇文章时，并没有实现Iterator。</p>
<h2 id="-">用作迭代器</h2>
<p>我们以一个简单的例子<sup id="fnref3"><a href="#fn3">3</a></sup>开始：</p>
<pre><code>function* argumentsGenerator() {
  for (let i = 0; i &lt; arguments.length; i += 1) {
    yield arguments[i];
  }
}
</code></pre><p>我们希望迭代传入的每个实参：</p>
<pre><code>var argumentsIterator = argumentsGenerator(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);

// Prints &quot;a b c&quot;
console.log(
    argumentsIterator.next().value,
    argumentsIterator.next().value,
    argumentsIterator.next().value
);
</code></pre><p>我们可以简单的理解：</p>
<ul>
<li>Generator其实是生成Iterator的方法。<code>argumentsGenerator</code>被称为<code>GeneartorFunction</code>，也有些人把<code>GeneartorFunction</code>的返回值称为一个<code>Geneartor</code>。</li>
<li><code>yield</code>可以中断<code>GeneartorFunction</code>的运行；而在下一次<code>yield</code>时，可以恢复运行。</li>
<li>返回的<code>Iterator</code>上，有<code>next</code>成员方法，能够返回迭代值。其中<code>value</code>属性包含实际返回的数值，<code>done</code>属性为布尔值，标记迭代器是否完成迭代。要注意的是，在<code>done</code>属性为<code>true</code>后继续运行<code>next</code>方法会产生异常。</li>
</ul>
<p>完整的ES实现中，<code>for-of</code>循环正是为了快速迭代一个<code>iterator</code>的：</p>
<pre><code>// Prints &quot;a&quot;, &quot;b&quot;, &quot;c&quot;
for(let value of argumentsIterator) {
  console.log(value);
}
</code></pre><p>可惜，目前版本的node不支持<code>for-of</code>。</p>
<p>说到这里，大多数有经验的Javascript程序员会表示不屑，因为这些都可以通过自己编写一个函数来实现。我们再来看一个例子：</p>
<pre><code>function* fibonacci() {
  let a = 0, b = 1;
  //1, 2
  while(true) {
    yield a;
    a = b;
    b = a + b;
  }
}

for(let value of fibonacci()) {
  console.log(value);
}
</code></pre><p>fibonacci序列是无穷的数字序列，你可以用函数的迭代来生成，但是远没有用Generator来的简洁。</p>
<p>再来个更有趣的。我们可以利用<code>yield*</code>语法，将yield操作代理到另外一个<code>Generator</code>。</p>
<pre><code>let delegatedIterator = (function* () {
  yield &#39;Hello!&#39;;
  yield &#39;Bye!&#39;;
}());

let delegatingIterator = (function* () {
  yield &#39;Greetings!&#39;;
  yield* delegatedIterator;
  yield &#39;Ok, bye.&#39;;
}());

// Prints &quot;Greetings!&quot;, &quot;Hello!&quot;, &quot;Bye!&quot;, &quot;Ok, bye.&quot;
for(let value of delegatingIterator) {
  console.log(value);
}
</code></pre><h2 id="-">用作流程控制</h2>
<p><code>yield</code>可以暂停运行流程，那么便为改变执行流程提供了可能<sup id="fnref4"><a href="#fn4">4</a></sup>。这和Python的coroutine类似。</p>
<p><a href="https://github.com/visionmedia/co">co</a>已经将此特性封装的非常完美了。我们在这里简单的讨论其实现。</p>
<blockquote>
<p>The classic example of this is consumer-producer relationships: generators that produce values, and then consumers that use them. The two generators are said to be symmetric – a continuous evaluation where coroutines yield to each other, rather than two functions that call each other.</p>
</blockquote>
<p>Geneartor之所以可用来控制代码流程，就是通过yield来将两个或者多个Geneartor的执行路径互相切换。这种切换是语句级别的，而不是函数调用级别的。其本质是CPS变幻，后文会给出解释。</p>
<p>这里要补充yield的若干行为：</p>
<ul>
<li>next方法接受一个参数，传入的参数是yield表达式的返回值；即yield既可以产生数值，也可以接受数值</li>
<li>throw方法会抛出一个异常，并终止迭代</li>
<li><code>GeneratorFunction</code>的return语句等同于一个yield</li>
</ul>
<h3 id="-">将异步“变”为同步</h3>
<p>假设我们希望有如下语法风格：</p>
<ul>
<li>suspend传入一个<code>GeneratorFunction</code></li>
<li>suspend返回一个简单的函数，接受一个node风格的回调函数</li>
<li>所有的异步调用都通过<code>yield</code>，看起来像同步调用</li>
<li>给定一个特殊的回调，让保证异步调用的返回值作为yield的返回值，并且让脚本继续</li>
<li><code>GeneratorFunction</code>的返回值和执行过程的错误都会会传入全局的回调函数</li>
</ul>
<p>更具体的，如下例子：</p>
<pre><code>var fs = require(&quot;fs&quot;);
suspend(function*(resume) {
  var content = yield fs.readFile(__filename, resume);
  var list = yield fs.readdir(__dirname, resume);
  return [content, list];
})(function(e, res) {
  console.log(e,res);
});
</code></pre><p>上面分别进行了一个读文件和列目录的操作，均是异步操作。为了实现这样的<code>suspend</code>和<code>resume</code>。我们简单的封装Generator的API：</p>
<pre><code>var slice = Array.prototype.slice.call.bind(Array.prototype.slice);

var suspend = function(gen) {//`gen` is a generator function
  return function(callback) {
    var args, iterator, next, ctx, done;
    ctx = this;
    args = slice(arguments);

    next = function(e) {
      if(e) {//throw up or send to callback
        return callback ? callback(e) : iterator.throw(e);
      }
      var ret = iterator.next(slice(arguments, 1));
      if(ret.done &amp;&amp; callback) {//run callback is needed
        callback(null, ret.value);
      }
    };

    resume = function(e) {
      next.apply(ctx, arguments);
    };

    args.unshift(resume);
    iterator = gen.apply(this, args);
    next();//kickoff
  };
};
</code></pre><h3 id="-">有容乃大</h3>
<p>目前我们只支持回调形势的API，并且需要显示的传入<code>resume</code>作为API的回调。为了像<code>co</code>那样支持更多的可以作为<code>yield</code>参数。<code>co</code>中，作者将所有形势的异步对象都归结为一种名为<code>thunk</code>的回调形式。</p>
<p>那什么是<code>thunk</code>呢？<code>thunk</code>就是支持标准的node风格回调的一个函数： <code>fn(callback)</code>。</p>
<p>首先我们将suspend修改为自动resume:</p>
<pre><code>var slice = Array.prototype.slice.call.bind(Array.prototype.slice);

var suspend = function(gen) {
  return function(callback) {
    var args, iterator, next, ctx, done;
    ctx = this;
    args = slice(arguments);
    next = function(e) {
      if(e) {
        return callback ? callback(e) : iterator.throw(e);
      }
      var ret = iterator.next(slice(arguments, 1));

      if(ret.done &amp;&amp; callback) {
        return callback(null, ret.value);
      }

      if(&quot;function&quot; === typeof ret.value) {//shold yield a thunk
        ret.value.call(ctx, function() {//resume function
          next.apply(ctx, arguments);
        });
      }

    };

    iterator = gen.apply(this, args);
    next();
  };
};
</code></pre><p>注意，这个时候，我们只能<code>yield</code>一个<code>thunk</code>，我们的使用方法也要发生改变：</p>
<pre><code>var fs = require(&quot;fs&quot;);
read = function(filename) {//wrap native API to a thunk
  return function(callback) {
    fs.readFile(filename, callback);
  };
};

suspend(function*() {//return value of this generator function is passed to callback
  return yield read(__filename);
})(function(e, res) {
  console.log(e,res);
});
</code></pre><p>接下来，我们要让这个suspend更加有用，我们可以支持如下内容穿入到yield</p>
<ul>
<li>GeneratorFunction</li>
<li>Generator</li>
<li>Thunk</li>
</ul>
<pre><code>var slice = Array.prototype.slice.call.bind(Array.prototype.slice);

var isGeneratorFunction = function(obj) {
  return obj &amp;&amp; obj.constructor &amp;&amp; &quot;GeneratorFunction&quot; == obj.constructor.name;
};

var isGenerator = function(obj) {
  return obj &amp;&amp; &quot;function&quot; == typeof obj.next &amp;&amp; &quot;function&quot; == typeof obj.throw;
};

var suspend = function(gen) {
  return function(callback) {
    var args, iterator, next, ctx, done, thunk;
    ctx = this;
    args = slice(arguments);
    next = function(e) {
      if(e) {
        return callback ? callback(e) : iterator.throw(e);
      }
      var ret = iterator.next(slice(arguments, 1));

      if(ret.done &amp;&amp; callback) {
        return callback(null, ret.value);
      }

      if(isGeneratorFunction(ret.value)) {//check if it&#39;s a generator
        thunk = suspend(ret.value);
      } else if(&quot;function&quot; === typeof ret.value) {//shold yield a thunk
        thunk = ret.value;
      } else if(isGenerator(ret.value)) {
        thunk = suspend(ret.value);
      }

      thunk.call(ctx, function() {//resume function
        next.apply(ctx, arguments);
      });

    };

    if(isGeneratorFunction(gen)) {
      iterator = gen.apply(this, args);
    } else {//assume it&#39;s a iterator
      iterator = gen;
    }
    next();
  };
};
</code></pre><p>在使用时，我们可以传入三种对象到yield：</p>
<pre><code>var fs = require(&quot;fs&quot;);
read = function(filename) {
  return function(callback) {
    fs.readFile(filename, callback);
  };
};

var read1 = function*() {
  return yield read(__filename);
};

var read2 = function*() {
  return yield read(__filename);
};

suspend(function*() {
  var one = yield read1;
  var two = yield read2();
  var three = yield read(__filename);
  return [one, two, three];
})(function(e, res) {
  console.log(e,res);
});
</code></pre><p>当然，到这里，大家应该都明白如何让<code>suspend</code>兼容更多的数据类型，例如<code>Promise</code>、数组等。但更多的扩展，在这里就不再赘述。这里的<code>suspend</code>可以就说就是精简的<code>co</code>了。</p>
<p><code>yield</code>的引入，让流程控制走上了一条康庄大道，不需要使用复杂的<code>Promise</code>、也不用使用难看的<code>async</code>。同时，从性能角度，yield可以通过V8的后续优化，性能进一步提升，目前来说<code>yield</code>的性能并不差<sup id="fnref5"><a href="#fn5">5</a></sup>。</p>
<h2 id="yield-">yield的转换</h2>
<p><code>yield</code>的本质是一个语法糖，底层的实现方式便是CPS变换<sup id="fnref6"><a href="#fn6">6</a></sup>。也就是说<code>yield</code>是可以用循环和递归重新实现的，根本用不着一定在V8层面实现。但笔者认为，纯Javascript实现的”yield”会造成大量的堆栈消耗，在性能上毫无优势可言。从性能上考虑，V8可以优化<code>yield</code>的编译，实现更高性能的转换。</p>
<p>关于CPS变换的细节，会在<a href="../Continuation_Passing_Style.html">之后的文章</a>中详细解说。</p>
<hr>
<div class="footnotes">
<ol>
<li id="fn1"><p><a href="http://callbackhell.com/">http://callbackhell.com/</a></p>
<a href="#fnref1" class="footnoteBackLink" title="Jump back to footnote 1 in the text.">↩</a></li>
<li id="fn2"><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators</a></p>
<a href="#fnref2" class="footnoteBackLink" title="Jump back to footnote 2 in the text.">↩</a></li>
<li id="fn3"><p><a href="https://github.com/JustinDrake/node-es6-examples#generators">https://github.com/JustinDrake/node-es6-examples#generators</a></p>
<a href="#fnref3" class="footnoteBackLink" title="Jump back to footnote 3 in the text.">↩</a></li>
<li id="fn4"><p><a href="http://dailyjs.com/2013/05/31/suspend/">http://dailyjs.com/2013/05/31/suspend/</a></p>
<a href="#fnref4" class="footnoteBackLink" title="Jump back to footnote 4 in the text.">↩</a></li>
<li id="fn5"><p><a href="http://dailyjs.com/2013/10/17/yield/">http://dailyjs.com/2013/10/17/yield/</a></p>
<a href="#fnref5" class="footnoteBackLink" title="Jump back to footnote 5 in the text.">↩</a></li>
<li id="fn6"><p><a href="http://en.wikipedia.org/wiki/Continuation-passing_style">http://en.wikipedia.org/wiki/Continuation-passing_style</a></p>
<a href="#fnref6" class="footnoteBackLink" title="Jump back to footnote 6 in the text.">↩</a></li>
</ol>
</div>

</div>
<footer class="misc clearfix">
  <p class="hint">建议在新版的Chrome、Safari、Firefox中阅读</p>
  <div class="left">
    <ul class="inline-list">
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/">Source</a></li>
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/blob/master/README.md">Contributors</a></li>
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/issues">Issues</a></li>
    </ul>
  </div>
  <div class="right">
    <ul class="inline-list">
      <li>Rev <a href="https://github.com/RobinQu/Programing-In-Javascript/tree/bf07b43/chapters/Javascript_Core/Functional_Javascript/Javascript_Generator.md">bf07b43</a></li>
      <li>2014-05-05T13:07:04.790Z</li>
    </ul>
  </div>
</footer>
</body>
</html>