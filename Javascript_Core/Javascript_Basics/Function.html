<!DOCTYPE html>
<html>
<head>
<title>函数 - Javascript编程语言</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Javascript编程语言 - 一本开源的Javascript编程指南; An open-sourced Javascript Guide and Tutorial; 函数 Javascript中，要记住函数是first-class citizen。 定义  函数声明语句       function plus(x ,y) {      }  函数定义表达式      var plus = function (x, y) {      } 函数调用  作为函数调用      function a(){};     a();  作为方法调用   a={};   a">
<meta name="keywords" content="Javascript, guide, open-sourced ">
<link rel="stylesheet" type="text/css" href="/style.css" />
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-313435-11', 'robinqu.me');
  ga('send', 'pageview');

</script>
</head>
<body>
<header class="clearfix">
  <div class="left back-toc">
    <ul class="inline-list">
      <li><a href="/">目录</a></li>
      
        <li class="seperator">></li>
        <li>Javascript核心</li>
      
        <li class="seperator">></li>
        <li>Javascript语法基础</li>
      
      
      <li class="seperator">></li>
      <li class="current"><strong>当前页面</strong></li>
      
      <li>(<a href="https://github.com/RobinQu/Programing-In-Javascript/edit/master/chapters/Javascript_Core/Javascript_Basics/Function.md">编辑</a>)</li>
    </ul>
  </div>
  <div class="right">
    <a href="/"><img src="/images/logo.png" alt="Javascript编程语言" width="256" height="50" /></a>
  </div>
</header>
<div class="primary">
  <h1 id="-">函数</h1>
<p>Javascript中，要记住函数是first-class citizen。</p>
<h2 id="-">定义</h2>
<ul>
<li>函数声明语句 </li>
</ul>
<pre><code>    function plus(x ,y) {

    }
</code></pre><ul>
<li>函数定义表达式</li>
</ul>
<pre><code>    var plus = function (x, y) {

    }
</code></pre><h2 id="-">函数调用</h2>
<ul>
<li>作为函数调用</li>
</ul>
<pre><code>    function a(){};
    a();
</code></pre><ul>
<li><p>作为方法调用</p>
<pre><code>  a={};
  a.x = function(){};
  a.x();
</code></pre></li>
<li><p>通过call和apply间接调用函数(改变this)</p>
</li>
</ul>
<p>call 和 apply带有多个参数，call和apply把当前函数的this指向第一个参数给定的函数或对象中，并传递其余所有的参数作为当前函数的参数。</p>
<pre><code>var O = function () {
    this.foo  = &#39;hello&#39;;
    this.hello = function () {
        return &#39;world&#39;;
    }
};

var fn = function () {
    console.log(&#39;call&#39;, this);
};

var o = new O();

fn.call(o);//此时fn的this指向o
</code></pre><p>call和apply的不同之处，在于call传递的参数是作为arguments依次传入的，例如</p>
<p><code>fn.call(o, 1, 2, 3);</code><br>而apply传递的参数是以一个数组的方式传入的，例如<br><code>fn.apply(o, [1, 2, 3]);</code></p>
<h2 id="-">参数</h2>
<p>当传入参数少于函数声明的参数时，留空的参数的值是<code>undefined</code>。</p>
<p>Javascript允许传入参数的个数大于声明时制定的参数个数。可以用<code>arguments</code>来访问这些参数</p>
<pre><code>function f(){
    var i;
    for( i = 0; i &lt; arguments.length ; i++) {
        console.log(arguments[i]);
    }
}

f(1,2,3,4,5,6);
</code></pre><p>函数通过取得arguments的长度得到传入参数的个数，使用一个循环获取每一个参数。</p>
<p>arguments还有两个属性，<code>callee</code>和<code>caller</code><br><code>callee</code>表示正在执行的function对象，<br><code>caller</code>表示调用当前function的function</p>
<p>例如</p>
<pre><code>function f(){
    console.log(arguments.callee);//[Function: f]
    console.log(arguments.callee.caller);[Function: g]
    var i;
    for( i = 0; i &lt; arguments.length ; i++) {
        console.log(arguments[i]);
    }
}

function g(){
    f(1,2,3,4,5,6);
}

g();
</code></pre><p> <code>callee</code> 的重要用法之一是在匿名函数中实现递归</p>
<pre><code>var result = function (x) {
    if (x &lt;= 1) return 1;
    return x * arguments.callee(x - 1);
}(3);

console.log(result);
</code></pre><p>上例使用了一个匿名函数和callee实现了一个阶乘。</p>
<h2 id="-">作为值的函数</h2>
<p>javascript中的函数可以作为值来传递</p>
<pre><code>function square(x) {
    return x * x;
}

var s = square;
s(4);
</code></pre><h2 id="-">作为命名空间的函数</h2>
<pre><code>(function() {

}());
</code></pre><h2 id="-">闭包</h2>
<p>Javascript函数对象的内部状态不仅包含着函数的代码逻辑，还引用当前的作用域链。函数对象通过作用域链相互关联起来，函数体内部变量包含在函数作用域内，这就叫闭包。</p>
<p>例如</p>
<pre><code>var scope = &#39;global scope&#39;;
function checkscope() {
    var scope = &#39;local scope&#39;;
    function f() { 
        return scope;
    }
    return f;
}

checkscope()();
</code></pre><p>这段checkscope声明了一个局部变量，定义了一个函数f，函数f返回了这个局部变量的值，最后返回了这个函数f。在定义函数f的作用域外调用f，得到的返回仍然是函数f创建时所在的作用域的局部变量scope。</p>
<p>又例如</p>
<pre><code>var counter = (function() {
    var count = 0;
    return function () {
        return count++ ;
    }
}());
</code></pre><p>代码定义了一个立即执行函数并返回给counter，这个函数定义了一个局部变量count，返回了一个子函数，该子函数每次调用，都会吧count加一并返回。</p>
<p><em>闭包的注意事项</em></p>
<p>观察下面的示例：</p>
<pre><code>var add_the_handlers = function (nodes) {
    var i;
        for (i = 0; i &lt; nodes.length; i += 1) {
            nodes[i].onclick = function (e) {
                alert(i);
            };
        }
};
</code></pre><p>这个函数期望的结果，是在运行的时候为每个node在onclick的时候alert出各自的序号，但是实际运行的结果却不同：所有的node在单击的时候alert出来的数字总是同一个。</p>
<p>这是因为alert所在的匿名函数的闭包中存放的i是第一行的i，而不是在循环中获得的i的当前值。</p>
<p>所以如果希望达到预期结果，应该在循环中创建多个闭包，在闭包中存放当前循环的i的值：</p>
<pre><code>var add_the_handlers = function (nodes) {
    var i;
        for (i = 0; i &lt; nodes.length; i += 1) {
            nodes[i].onclick = function (i) {
                return function(e){
                    alert(e);
                };
            }(i);
        }
};
</code></pre><p>这里使用一个立即执行函数并传递当前的i的值，返回一个新生成的函数。在这个新生成的函数的闭包中就保存了当前的i的值。</p>
<h2 id="-this-">函数中的this对象</h2>
<p>在一个对象中的this始终引用当前对象，但是在函数中，特别是在闭包中，this有一些特殊的行为。</p>
<p>函数中的this对象始终绑定在函数运行时的上下文环境上。所以在普通模式下调用一个全局函数，this始终指向window（客户端），在严格模式下调用一个全局函数，this始终是undefined</p>
<p>示例</p>
<pre><code>var name = &quot;The Window&quot;;
var object = {
    name: &quot;My Object&quot;,
    getNameFunc: function () {
        return function () {
            return this.name;
        };
    },
    getName : function () {
        return this.name;
    }
};

console.log(object.getNameFunc()());
console.log(object.getName());
</code></pre><p>getNameFunction()返回了一个匿名函数，这个匿名函数在调用的时候，上下文是window（浏览器中），所以在浏览器中输出的是the Window</p>
<p>而getName()调用的时候上下文是object，所以成功输出object的name</p>
<p>其实以上代码中<br>    object.getNameFunc()()<br>等效于<br>    var fnc = object.getNameFunc();//这时候的fnc已经脱离了object对象<br>    fnc();</p>
<p>所以如果想要getNameFunction()正确返回Object的Name，需要在返回的匿名函数的闭包中保存在函数声明时的this，</p>
<pre><code>getNameFunc: function () {
        var that = this;
        return function () {
            return that.name;
        };
    },
</code></pre><p>这样就可以了。。</p>
<h2 id="-">函数柯里化</h2>
<p>函数柯里化是指，把接受多个参数的函数转换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<p>示例</p>
<pre><code>var add1 = add.curry(1);
console.log(add1(2));
</code></pre><p>其中，add是接受两个参数的函数，add调用了curry返回一个只接受一个参数的新函数，之后调用add1便等效于调用add(1, 2);</p>
<p>javascript并不原生支持curry，可以用prototype来模拟</p>
<pre><code>Function.prototype.curry = function () {
    var slice = Array.prototype.slice,
        args = slice.apply(arguments),
        that = this;
    return function () {
        return that.apply(null, args.concat(slice.apply(arguments)));
    };
};


function add(n1, n2) {
    return n1 + n2;
}

var add1 = add.curry(1);
console.log(add1(2));
</code></pre><p>curry创建了一个新函数，在新函数的闭包中保存了原先传递的参数。</p>
<h2 id="-">函数的属性和方法</h2>
<ul>
<li><code>length</code> 函数的length表示函数实参的数量，是只读的</li>
<li><code>prototype</code> 指向一个该函数的原型对象的引用</li>
<li><code>toString</code> 返回一个字符串</li>
</ul>

</div>
<footer class="misc clearfix">
  <p class="hint">建议在新版的Chrome、Safari、Firefox中阅读</p>
  <div class="left">
    <ul class="inline-list">
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/">Source</a></li>
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/blob/master/README.md">Contributors</a></li>
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/issues">Issues</a></li>
    </ul>
  </div>
  <div class="right">
    <ul class="inline-list">
      <li>Rev <a href="https://github.com/RobinQu/Programing-In-Javascript/tree/783ce22/chapters/Javascript_Core/Javascript_Basics/Function.md">783ce22</a></li>
      <li>2014-05-12T04:32:54.140Z</li>
    </ul>
  </div>
</footer>
</body>
</html>