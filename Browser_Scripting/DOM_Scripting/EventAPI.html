<!DOCTYPE html>
<html>
<head>
<title>Event接口 - Javascript编程语言</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Javascript编程语言 - 一本开源的Javascript编程指南; An open-sourced Javascript Guide and Tutorial; Event接口 事件机制无时无刻伴随着Javascript开发。在浏览器环境里有各种各样的事件。正是这些事件驱动着脚本的运行。 Javascript的事件机制也是一个标准的观察者模式（Observer Pattern）的应用。通过抽象出订阅者（Subscriber）和发布者（Publisher）来达到接偶某个事物的目的。这样一种普遍的设计模式，不仅仅可以用在DOM里的事件机制，应用程序的脚本也可以">
<meta name="keywords" content="Javascript, guide, open-sourced ,决定,,0,,2,,3,,#,,Event,,接口,,事件,,机制,,无时无刻,,伴随着,,Javascript,,开发,,。,,在,,浏览器,,环境,,里,,有,,各种各样,,的,,正是,,这些,,驱动,,着,,脚本,,运行,,也是,,一个,,标准,,观察者,,模式,,（,,Observer,,Pattern,,）,,应用,,通过,,抽象,,出,,订阅,,者,,Subscriber,,和,,发布者,,Publisher,,来,,达到,,接偶,,某个,,事物,,目的,,这样,,一种,,普遍的,,设计,,，,,不仅仅,,可以,,用,,DOM,,应用程序,,也,,构建,,自己,,模型,,产生,,自定义,,推动,,进行,,例如,,`,,Backbone,,.,,就是,,常见的,,EventEmitter,,实现,,它,,允许,,任何,,对象,,派发,,而,,不,,局限,,于,,中的,,文档,,元素,,作为,,中,,最,,完善,,复杂的,,自然,,是,,程序员,,首先,,要,,掌握,,概述,,EventTarget,,节点,,内,,传播,,或,,总是,,沿着,,其,,附,,所,,构成,,有序,,列表,,编程,,时时,,源头,,很多,,同时,,存在,,多种,,形式,,从事,,件,,看,,拥有,,能够,,接受,,都,,了,,下面,,这,,三个方,,法,,大家,,应该,,陌生,,addEventListener,,(,,),,removeEventListener,,dispatchEvent,,大多,,有如,,下,,继承,,状态,,:,,-,,&gt;,,Node,,|,,Element,,HTMLElement,,Document,,如上所述,,素,,我们,,获取,,都是,,相关,,方法,,但,,由于,,历史,,原因,,大量,,时期,,即,,没有,,标准化,,代码,,使用,,以下,,两种,,办法,,注册,,监听,,：,,*,,HTML,,属性,,&lt;,,button,,onclick,,=,,&quot;,,alert,,&#x27;,,Hello,,world,,!,,myButton,,function,,event,,{,,;,,},,调用,,需要,,遵循,,该,,行为,,自动,,相应,,整个,,流程,,如下,,1,,时间,,路径,,将要,,组成,,里面,,这个,,最后,,一点,,Target,,本身,,之前,,祖先,,[,,Flow,,],,eventflow,,png,,关于,,两个,,特性,,一旦,,被,,确定,,即使,,后续,,操作,,改变,,结构,,不会,,影响,,内容,,更,,处理,,函数,,callback,,、,,handler,,subscriber,,过程,,出现,,捕获,,异常,,也不,,会,,三个,,阶段,,capture,,phase,,目标,,target,,冒泡,,bubble,,标记,,bubbles,,描述,,是否,,经历,,eventPhase,,正在,,正,,处于,,哪个,,对,,stopPropagation,,阻止,,继续,,接着,,上,,每个,,listeners,,此时,,按照,,条件,,向,,哪些,,stopImmediatePropagation,,立刻,,停止,,的确,,pahase,,类型,,type,,当,,完成,,所有,,周期,,后,,currentTarget,,必须,,设置,,为,,null,,其他,,保持,,不变,,可,,递归,,如果,,要求,,新的,,新,,同步,,执行,,并且,,只有,,完毕,,才,,默认,,preventDefault,,通常,,包含,,有一些,,取消,,抛弃,,就,,那么,,后果,,将,,重置,,cancelable,,；,,defaultPrevented,,已经,,返回,,值,,反应,,激活,,Activataion,,用户,,或者,,另外,,连带,,触发,,比较,,而且,,大多数,,不支持,,但是,,聚焦,,Focused,,链接,,敲击,,Enter,,键,,页面,,跳转,,重新,,定位,,Activation,,Trigger,,keydown,,Behavior,,有趣的,,并,,不是,,由,,click,,模拟,,鼠标,,左,,点击,,除了,,keypress,,之外,,还,,想象,,一下,,语音,,控制,,触屏,,交互,,网页,,浏览,,场景,,做法,,有道理,,保证,,大,,兼容性,,可信,,发生,,变化,,DocumentEvent,,createEvent,,创建,,initEvent,,初始化,,以及,,合成,,不可信,,isTrusted,,大部分,,不允许,,DOMActivate,,除外,,模块,,常见,,分类,,UIEvent,,MouseEvent,,WheelEvent,,KeyboardEvent,,CompositionEvent,,InputEvent,,FocusEvent,,参考,,http://www.w3.org/TR/DOM-Level-3-Events,,http://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handler-attributes">
<link rel="stylesheet" type="text/css" href="/style.css" />

</head>
<body>
<header class="clearfix">
  <div class="left back-toc">
    <ul class="inline-list">
      <li><a href="/">目录</a></li>
      
        <li class="seperator">></li>
        <li>面向浏览器编程</li>
      
        <li class="seperator">></li>
        <li>DOM编程</li>
      
      
      <li class="seperator">></li>
      <li class="current"><strong>当前页面</strong></li>
      
    </ul>
  </div>
  <div class="right">
    <a href="/"><img src="/images/logo.png" alt="Javascript编程语言" width="256" height="50" /></a>
  </div>
</header>
<div class="primary">
  <h1 id="event-">Event接口</h1>
<p>事件机制无时无刻伴随着Javascript开发。在浏览器环境里有各种各样的事件。正是这些事件驱动着脚本的运行。</p>
<p>Javascript的事件机制也是一个标准的观察者模式（Observer Pattern）的应用。通过抽象出订阅者（Subscriber）和发布者（Publisher）来达到接偶某个事物的目的。这样一种普遍的设计模式，不仅仅可以用在DOM里的事件机制，应用程序的脚本也可以构建自己的事件模型，产生自定义的事件来推动应用程序的进行，例如<code>Backbone.Event</code>就是一种常见的EventEmitter实现，它允许任何对象进行事件派发，而不局限于DOM中的文档元素。</p>
<p>作为浏览器中最完善也是最复杂的DOM事件，自然是Javascript程序员首先要掌握的。</p>
<h2 id="dom-">DOM事件概述</h2>
<h3 id="eventtarget-">EventTarget和节点元素</h3>
<p>DOM内的事件传播（或事件派发）总是沿着其文档节点和其附元素所构成的有序列表进行的。</p>
<p>在应用Javascript进行DOM编程时时，事件的产生源头很多，同时，事件的订阅也存在多种形式。从事件源头看，拥有能够接受事件DOM事件的对象，都实现了<code>EventTarget</code>接口。下面这三个方法，大家应该都不陌生。</p>
<pre><code>EventTarget.addEventListener ()
EventTarget.removeEventListener ()
EventTarget.dispatchEvent ()
</code></pre><p>DOM内的文档元素，大多都有如下的继承状态:</p>
<pre><code>EventTarget -&gt; Node -&gt; |-&gt; Element -&gt; HTMLElement -&gt; ...
                       |-&gt; Document
                       |-&gt; ...
</code></pre><p>如上所述，大多素我们获取的节点，都是有相关的事件方法的。但由于历史原因，有大量DOM0时期（即没有标准化）的代码，可以使用以下两种办法注册事件监听：</p>
<ul>
<li><p>通过HTML属性</p>
<pre><code>  &lt;button onclick=&quot;alert(&#39;Hello world!&#39;)&quot;&gt;
</code></pre></li>
<li><p>通过DOM元素属性</p>
<pre><code>  myButton.onclick = function(event){alert(&#39;Hello world&#39;);};
</code></pre></li>
</ul>
<h3 id="-">事件派发</h3>
<p>事件可以通过调用<code>EventTarget.dispatchEvent()</code>进行派发，浏览器自己也需要遵循该方法的行为自动派发相应事件。整个事件派发的流程如下：</p>
<p>首先，浏览器实现要决定时间对象的传播路径。事件传播路径是事件将要通过的节点组成的有序列表。在DOM里面，这个事件传播路径的最后一点就是事件对象（Event Target）本身，其之前的元素就是事件对象的祖先元素。</p>
<p><img src="eventflow.png" alt="Event Flow"></p>
<p>关于事件派发的路径，有两个特性：</p>
<ol>
<li><p>一旦这个传播路径被确定，即使后续的操作改变了文档结构，也不会影响这个有序列表中的内容，更不会影响事件的派发</p>
</li>
<li><p>事件处理函数（callback、handler、subscriber）的处理过程中出现了没有捕获的异常，也不会影响事件的派发</p>
</li>
</ol>
<p>事件派发的过程，本身有三个阶段：</p>
<ol>
<li>捕获阶段(capture phase)</li>
<li>目标阶段(target phase)</li>
<li>冒泡阶段(bubble phase)</li>
</ol>
<p>一个事件对象有很多相关的属性，来标记这三个阶段的状态，例如<code>Event.bubbles</code>描述一个事件是否可以经历冒泡阶段，<code>Event.eventPhase</code>来描述正在传播的这个事件正处于哪个阶段。</p>
<p>一个事件对象也有相关的方法对事件传播产生影响，例如<code>Event.stopPropagation()</code>会阻止事件的继续传播。</p>
<p>接着，浏览器实现会确定派发路径上每个对象所拥有的事件监听者(event listeners)。此时确定的监听者列表，在后续的操作中也不会被改变。</p>
<p>最后，浏览器实现会按照如下三个条件来决定向哪些事件监听者派发事件：</p>
<ol>
<li>事件对象没有调用<code>Event.stopImmediatePropagation()</code>来立刻停止事件传播</li>
<li>该监听者的确注册在这个事件传播阶段(event pahase)</li>
<li>该监听者的确注册了这个类型的事件(event type)</li>
</ol>
<p>当一个事件完成了所有传播周期后，它的<code>Event.currentTarget</code>必须设置为<code>null</code>，<code>Event.eventPhase</code>必须为0。事件的其他属性保持不变。</p>
<p>事件派发是可递归产生的，如果在事件处理函数中，浏览器被要求派发新的事件，新产生的事件派发会被同步执行，并且只有在新的事件派发完毕后，之前的事件传播才会继续。</p>
<h3 id="-">事件的默认行为</h3>
<p>可以被阻止的事件（<code>Event.preventDefault()</code>），通常包含有一些浏览器默认行为。当事件被取消，这些默认行为会被抛弃。有一些事件的默认行为是在事件传播之前就执行了的，那么这些行为所产生的后果将被重置。事件的<code>Event.cancelable</code>描述该事件是否可以被取消；事件的<code>Event.defaultPrevented</code>描述一个事件的默认行为是否已经被阻止。如果一个事件是有脚本派发的，那么<code>EventTarget.dispatchEvent</code>方法的返回值也会反应这个事件是否被阻止执行默认行为。</p>
<p>激活事件（Activataion event）是有用户操作或者另外一个事件连带触发的一种事件。激活事件本身比较抽象，而且大多数浏览器都不支持，但是它和时间的默认行为相关。</p>
<p>例如，当用户在已经聚焦(Focused)的链接上敲击<code>Enter</code>键，那么页面会跳转或重新定位。此时，激活事件的触发者(Activation Trigger)是<code>keydown</code>事件，激活行为(Activation Behavior)是链接的跳转。</p>
<p>有趣的是，当激活事件并不是由一个<code>click</code>事件产生的，那么激活事件的默认行为会产生一个模拟的<code>click</code>事件，来描述一个鼠标的左键点击。即，除了<code>keypress</code>事件之外，还会产生一个<code>click</code>事件。</p>
<p>想象一下语音控制和触屏交互下的网页浏览场景，这样的做法是有道理的，也保证了大代码的兼容性。</p>
<h3 id="-">可信事件</h3>
<p>有用户交互DOM本身发生变化所产生的事件是可信事件。由<code>DocumentEvent.createEvent()</code>方法创建的事件、<code>Event.initEvent()</code>方法初始化的事件、<code>EventTarget.dispatchEvent()</code>方法派发的事件以及合成事件都是不可信的。事件的<code>Event.isTrusted</code>描述一个事件是否可信。大部分不可信事件不允许触发默认行为，<code>click</code>事件和<code>DOMActivate</code>事件除外。</p>
<h2 id="-">事件模块</h2>
<p>常见事件分类</p>
<h3 id="uievent">UIEvent</h3>
<h3 id="mouseevent-wheelevent">MouseEvent和WheelEvent</h3>
<h3 id="keyboardevent">KeyboardEvent</h3>
<h3 id="compositionevent">CompositionEvent</h3>
<h3 id="-">其他事件</h3>
<ul>
<li>InputEvent</li>
<li>FocusEvent</li>
</ul>
<h3 id="-">自定义事件</h3>
<h2 id="-">参考文档</h2>
<ul>
<li><a href="http://www.w3.org/TR/DOM-Level-3-Events">http://www.w3.org/TR/DOM-Level-3-Events</a></li>
<li><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handler-attributes">http://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handler-attributes</a></li>
</ul>

</div>
<footer class="misc clearfix">
  <p class="hint">建议在新版的Chrome、Safari、Firefox中阅读</p>
  <div class="left">
    <ul class="inline-list">
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/">Source</a></li>
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/blob/master/README.md">Contributors</a></li>
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/issues">Issues</a></li>
    </ul>
  </div>
  <div class="right">
    <ul class="inline-list">
      <li>Rev <a href="https://github.com/RobinQu/Programing-In-Javascript/tree/bf07b43/chapters/Browser_Scripting/DOM_Scripting/EventAPI.md">bf07b43</a></li>
      <li>2014-05-05T13:07:04.790Z</li>
    </ul>
  </div>
</footer>
</body>
</html>