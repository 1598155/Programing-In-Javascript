<!DOCTYPE html>
<html>
<head>
<title>Event接口 - Javascript编程语言</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="Javascript编程语言 - 一本开源的Javascript编程指南; An open-sourced Javascript Guide and Tutorial">
<meta name="keywords" content="Javascript, guide, open-sourced">
<link rel="stylesheet" type="text/css" href="/style.css" />

</head>
<body>
<header class="clearfix">
  <div class="left back-toc">
    <ul class="inline-list">
      <li><a href="/">目录</a></li>
      
        <li class="seperator">></li>
        <li>面向浏览器编程</li>
      
        <li class="seperator">></li>
        <li>DOM编程</li>
      
      
      <li class="seperator">></li>
      <li class="current"><strong>当前页面</strong></li>
      
    </ul>
  </div>
  <div class="right">
    <a href="/"><img src="/images/logo.png" alt="Javascript编程语言" width="256" height="50" /></a>
  </div>
</header>
<div class="primary">
  <h1 id="event-">Event接口</h1>
<p>事件机制无时无刻伴随着Javascript开发。在浏览器环境里有各种各样的事件。正是这些事件驱动着脚本的运行。</p>
<p>Javascript的事件机制也是一个标准的观察者模式（Observer Pattern）的应用。通过抽象出订阅者（Subscriber）和发布者（Publisher）来达到接偶某个事物的目的。这样一种普遍的设计模式，不仅仅可以用在DOM里的事件机制，应用程序的脚本也可以构建自己的事件模型，产生自定义的事件来推动应用程序的进行，例如<code>Backbone.Event</code>就是一种常见的EventEmitter实现，它允许任何对象进行事件派发，而不局限于DOM中的文档元素。</p>
<p>作为浏览器中最完善也是最复杂的DOM事件，自然是Javascript程序员首先要掌握的。</p>
<h2 id="dom-">DOM事件概述</h2>
<h3 id="eventtarget-">EventTarget和节点元素</h3>
<p>DOM内的事件传播（或事件派发）总是沿着其文档节点和其附元素所构成的有序列表进行的。</p>
<p>在应用Javascript进行DOM编程时时，事件的产生源头很多，同时，事件的订阅也存在多种形式。从事件源头看，拥有能够接受事件DOM事件的对象，都实现了<code>EventTarget</code>接口。下面这三个方法，大家应该都不陌生。</p>
<pre><code>EventTarget.addEventListener ()
EventTarget.removeEventListener ()
EventTarget.dispatchEvent ()
</code></pre><p>DOM内的文档元素，大多都有如下的继承状态:</p>
<pre><code>EventTarget -&gt; Node -&gt; |-&gt; Element -&gt; HTMLElement -&gt; ...
                       |-&gt; Document
                       |-&gt; ...
</code></pre><p>如上所述，大多素我们获取的节点，都是有相关的事件方法的。但由于历史原因，有大量DOM0时期（即没有标准化）的代码，可以使用以下两种办法注册事件监听：</p>
<ul>
<li><p>通过HTML属性</p>
<pre><code>  &lt;button onclick=&quot;alert(&#39;Hello world!&#39;)&quot;&gt;
</code></pre></li>
<li><p>通过DOM元素属性</p>
<pre><code>  myButton.onclick = function(event){alert(&#39;Hello world&#39;);};
</code></pre></li>
</ul>
<h3 id="-">事件派发</h3>
<p>事件可以通过调用<code>EventTarget.dispatchEvent()</code>进行派发，浏览器自己也需要遵循该方法的行为自动派发相应事件。整个事件派发的流程如下：</p>
<p>首先，浏览器实现要决定时间对象的传播路径。事件传播路径是事件将要通过的节点组成的有序列表。在DOM里面，这个事件传播路径的最后一点就是事件对象（Event Target）本身，其之前的元素就是事件对象的祖先元素。</p>
<p><img src="eventflow.png" alt="Event Flow"></p>
<p>关于事件派发的路径，有两个特性：</p>
<ol>
<li><p>一旦这个传播路径被确定，即使后续的操作改变了文档结构，也不会影响这个有序列表中的内容，更不会影响事件的派发</p>
</li>
<li><p>事件处理函数（callback、handler、subscriber）的处理过程中出现了没有捕获的异常，也不会影响事件的派发</p>
</li>
</ol>
<p>事件派发的过程，本身有三个阶段：</p>
<ol>
<li>捕获阶段(capture phase)</li>
<li>目标阶段(target phase)</li>
<li>冒泡阶段(bubble phase)</li>
</ol>
<p>一个事件对象有很多相关的属性，来标记这三个阶段的状态，例如<code>Event.bubbles</code>描述一个事件是否可以经历冒泡阶段，<code>Event.eventPhase</code>来描述正在传播的这个事件正处于哪个阶段。</p>
<p>一个事件对象也有相关的方法对事件传播产生影响，例如<code>Event.stopPropagation()</code>会阻止事件的继续传播。</p>
<p>接着，浏览器实现会确定派发路径上每个对象所拥有的事件监听者(event listeners)。此时确定的监听者列表，在后续的操作中也不会被改变。</p>
<p>最后，浏览器实现会按照如下三个条件来决定向哪些事件监听者派发事件：</p>
<ol>
<li>事件对象没有调用<code>Event.stopImmediatePropagation()</code>来立刻停止事件传播</li>
<li>该监听者的确注册在这个事件传播阶段(event pahase)</li>
<li>该监听者的确注册了这个类型的事件(event type)</li>
</ol>
<p>当一个事件完成了所有传播周期后，它的<code>Event.currentTarget</code>必须设置为<code>null</code>，<code>Event.eventPhase</code>必须为0。事件的其他属性保持不变。</p>
<p>事件派发是可递归产生的，如果在事件处理函数中，浏览器被要求派发新的事件，新产生的事件派发会被同步执行，并且只有在新的事件派发完毕后，之前的事件传播才会继续。</p>
<h3 id="-">事件的默认行为</h3>
<p>可以被阻止的事件（<code>Event.preventDefault()</code>），通常包含有一些浏览器默认行为。当事件被取消，这些默认行为会被抛弃。有一些事件的默认行为是在事件传播之前就执行了的，那么这些行为所产生的后果将被重置。事件的<code>Event.cancelable</code>描述该事件是否可以被取消；事件的<code>Event.defaultPrevented</code>描述一个事件的默认行为是否已经被阻止。如果一个事件是有脚本派发的，那么<code>EventTarget.dispatchEvent</code>方法的返回值也会反应这个事件是否被阻止执行默认行为。</p>
<p>激活事件（Activataion event）是有用户操作或者另外一个事件连带触发的一种事件。激活事件本身比较抽象，而且大多数浏览器都不支持，但是它和时间的默认行为相关。</p>
<p>例如，当用户在已经聚焦(Focused)的链接上敲击<code>Enter</code>键，那么页面会跳转或重新定位。此时，激活事件的触发者(Activation Trigger)是<code>keydown</code>事件，激活行为(Activation Behavior)是链接的跳转。</p>
<p>有趣的是，当激活事件并不是由一个<code>click</code>事件产生的，那么激活事件的默认行为会产生一个模拟的<code>click</code>事件，来描述一个鼠标的左键点击。即，除了<code>keypress</code>事件之外，还会产生一个<code>click</code>事件。</p>
<p>想象一下语音控制和触屏交互下的网页浏览场景，这样的做法是有道理的，也保证了大代码的兼容性。</p>
<h3 id="-">可信事件</h3>
<p>有用户交互DOM本身发生变化所产生的事件是可信事件。由<code>DocumentEvent.createEvent()</code>方法创建的事件、<code>Event.initEvent()</code>方法初始化的事件、<code>EventTarget.dispatchEvent()</code>方法派发的事件以及合成事件都是不可信的。事件的<code>Event.isTrusted</code>描述一个事件是否可信。大部分不可信事件不允许触发默认行为，<code>click</code>事件和<code>DOMActivate</code>事件除外。</p>
<h2 id="-">事件模块</h2>
<p>常见事件分类</p>
<h3 id="uievent">UIEvent</h3>
<h3 id="mouseevent-wheelevent">MouseEvent和WheelEvent</h3>
<h3 id="keyboardevent">KeyboardEvent</h3>
<h3 id="compositionevent">CompositionEvent</h3>
<h3 id="-">其他事件</h3>
<ul>
<li>InputEvent</li>
<li>FocusEvent</li>
</ul>
<h3 id="-">自定义事件</h3>
<h2 id="-">参考文档</h2>
<ul>
<li><a href="http://www.w3.org/TR/DOM-Level-3-Events">http://www.w3.org/TR/DOM-Level-3-Events</a></li>
<li><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handler-attributes">http://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handler-attributes</a></li>
</ul>

</div>
<footer class="misc clearfix">
  <p class="hint">建议在新版的Chrome、Safari、Firefox中阅读</p>
  <div class="left">
    <ul class="inline-list">
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/">Source</a></li>
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/blob/master/README.md">Contributors</a></li>
      <li><a href="https://github.com/RobinQu/Programing-In-Javascript/issues">Issues</a></li>
    </ul>
  </div>
  <div class="right">
    <ul class="inline-list">
      <li>Rev <a href="https://github.com/RobinQu/Programing-In-Javascript/tree/0d2344c/chapters/Browser_Scripting/DOM_Scripting/EventAPI.md">0d2344c</a></li>
      <li>Thu Mar 27 2014 19:28:27 GMT+0800 (CST)</li>
    </ul>
  </div>
</footer>
</body>
</html>